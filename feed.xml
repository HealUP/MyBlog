<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom"><id>https://github.com/HealUP/MyBlog</id><title>RSS feed of HealUP's MyBlog</title><updated>2023-05-12T11:32:07.628507+00:00</updated><author><name>HealUP</name><email>1571826275@qq.com</email></author><link href="https://github.com/HealUP/MyBlog"/><link href="https://raw.githubusercontent.com/HealUP/MyBlog/master/feed.xml" rel="self"/><generator uri="https://lkiesow.github.io/python-feedgen" version="0.9.0">python-feedgen</generator><entry><id>https://github.com/HealUP/MyBlog/issues/24</id><title>剑指 Offer 29. 顺时针打印矩阵</title><updated>2023-05-12T11:32:08.052258+00:00</updated><content type="html"><![CDATA[<h3>[<a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/">剑指 Offer 29. 顺时针打印矩阵</a>](https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/)</h3>
<p><strong>思路分析：根据题目示例 matrix = [[1,2,3],[4,5,6],[7,8,9]] 的对应</strong>输出 [1,2,3,6,9,8,7,4,5] 可以发现，顺时针打印矩阵的顺序是 “从左向右、从上向下、从右向左、从下向上” 循环。</p>
<p><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-d">https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/solution/mian-shi-ti-29-shun-shi-zhen-da-yin-ju-zhen-she-d</a></p>
<pre><code class="language-java">class Solution {
    public int[] spiralOrder(int[][] matrix) {
        if (matrix.length == 0) return new int [0];//矩阵为空，返回空数组即可
        int l = 0, r = matrix[0].length-1, t = 0, b = matrix.length - 1, x = 0;//r 是列长度，即宽度b是行长度，即高度
        int[] res = new int[(r + 1) * (b + 1)];//数组的大小就是二维数组相乘的大小
        while (true) {
            //left to right
            for (int i = l; i &lt;= r; i++) {
                res[x++] = matrix[t][i];
            }
            //top大于bottom出边界了
            if(++t &gt; b) {
                break;
            }
            //top to bottom
            for (int i = t; i &lt;= b; i++) {
                res[x++] = matrix[i][r];
            }
            if (--r &lt; l) {
                break;
            }
            //right to left
            for (int i = r; i &gt;= l; i--) {
                res[x++] = matrix[b][i];
            }
            if (--b &lt;t) {
                break;
            }
            //bottom to top
            for (int i = b; i &gt;= t; i--) {
                res[x++] = matrix[i][l];
            }
            if (++l &gt; r) {
                break;
            }
        }
        return res;
    }
}
</code></pre>
<blockquote>
<p>小厂笔试第一题</p>
</blockquote>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/24" rel="alternate"/><category term="算法"/><category term="模拟"/><published>2023-05-12T11:30:48+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/23</id><title>LC 226.翻转二叉树 ⭐⭐⭐⭐</title><updated>2023-05-12T11:32:08.229840+00:00</updated><content type="html"><![CDATA[<h3>226. 翻转二叉树</h3>
<blockquote>
<p>解决方案包括<strong>递归法</strong>和<strong>非递归</strong>法：</p>
<ul>
<li>递归法 实现前中后序遍历</li>
<li>
非递归法即<strong>迭代法</strong>，包括：<ul>
<li><strong>深度</strong>优先搜索 DFS 使用<strong>栈</strong>模拟 <strong>实现前中后序遍历</strong> =&gt; 基于栈的深搜其实还不好写统一的前中后序遍历，但是有统一的写法，一刷的时候，由于比较赶，先不写。先掌握<strong>递归</strong>的写法🐛</li>
<li><strong>广度</strong>优先搜索 BFS 使用<strong>队列</strong>模拟 <strong>实现层序遍历</strong></li>
</ul>
</li>
</ul>
</blockquote>
<p><strong>法一：递归法</strong>（<strong>这道题目使用前序遍历和后序遍历都可以，唯独中序遍历不方便，因为中序遍历会把某些节点的左右孩子翻转了两次</strong>）</p>
<p><strong>首先确定三要素：</strong></p>
<ul>
<li>确定递归函数的<strong>参数</strong>和<strong>返回值</strong></li>
<li>确定<strong>终止条件</strong></li>
<li>确定<strong>单层递归</strong>的逻辑</li>
</ul>
<pre><code class="language-java">class Solution {
    //递归函数
    public TreeNode invertTree(TreeNode root) {
        //递归法
        if (root == null) {
            return root;
        }
        //直接交换，使用前序遍历
        swapChildren(root);//中
        invertTree(root.left);//左节点放入  反转的时候将左节点的左右子节点翻转
        invertTree(root.right);//右节点放入 
        return root;
    }
    //交换左右节点
    public void swapChildren (TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
</code></pre>
<p><strong>法二：迭代法—层序遍历</strong></p>
<blockquote>
<p>思路：层序遍历，每一层分别反转</p>
</blockquote>
<pre><code class="language-java">class Solution {
    public TreeNode invertTree(TreeNode root) {
       //层序遍历 每一层的节点分别翻转
       if (root == null) {return null;}
       Queue&lt;TreeNode&gt; que = new LinkedList&lt;&gt;();
       que.offer(root);
       while (!que.isEmpty()) {
           int len = que.size();
           for (int i = 0; i &lt; len; i++) {
               TreeNode node = que.poll();
               swapChildren(node);
               if (node.left != null) que.offer(node.left);
               if (node.right != null) que.offer(node.right);
           }
       }
       return root;
    }

    //交换左右节点
    public void swapChildren (TreeNode root) {
        TreeNode temp = root.left;
        root.left = root.right;
        root.right = temp;
    }
}
</code></pre>
<h3></h3>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/23" rel="alternate"/><category term="算法"/><category term="二叉树"/><published>2023-05-12T11:28:53+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/22</id><title>LC双周赛 —6300. 最小公共值</title><updated>2023-05-12T11:32:08.405702+00:00</updated><content type="html"><![CDATA[<p>##第 96 场</p>
<p><strong>双周赛 —6300. 最小公共值</strong></p>
<p>题目链接：<a href="https://leetcode.cn/contest/biweekly-contest-96/problems/minimum-common-value/">https://leetcode.cn/contest/biweekly-contest-96/problems/minimum-common-value/</a></p>
<p>自己写的：</p>
<pre><code class="language-java">class Solution {
    public int getCommon(int[] nums1, int[] nums2) {
        //哈希法 set集合实现，因为无法判断输入数组的大小 浪费空间会比较大
        //判断临界条件
        // if ( nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
        //     return -1;//返回-1
        // }
        
        //存入nums1数组到set集合
        Set&lt;Integer&gt; set = new HashSet&lt;&gt;();
        for (int i : nums1) {
            set.add(i);
        }
        //存放结果集
        Set&lt;Integer&gt; resSet = new HashSet&lt;&gt;();
        //遍历nums2同时判断nums1的集合中否存在这个元素，存在的放入resSet中
        for (int i : nums2) {
            if (set.contains(i)) {
                resSet.add(i);
            }
        }
        //返回数组的第一个元素
     int[] res = resSet.stream().mapToInt(x -&gt; x).toArray();
        
        if (res != null &amp;&amp; res.length != 0) {
            Arrays.sort(res);//升序
            return res[0];
        } else {
            return -1;
        }
        
    }
}
</code></pre>
<p>优化：因为题目告诉我们，它们已经按非降序排序（即已按升序排序）不用将交集放到另外一个集合了，直接第一个找到了就返回该数就好。</p>
<pre><code class="language-java">class Solution {
    public int getCommon(int[] nums1, int[] nums2) {
        Set&lt;Integer&gt; set = new HashSet&lt;Integer&gt;();
        for (int num : nums1) {
            set.add(num);
        }
        for (int num2 : nums2) {
            if (set.contains(num2)) {
                return num;
            }
        }
        return -1;
    }
}
</code></pre>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/22" rel="alternate"/><category term="算法"/><category term="哈希法"/><published>2023-05-11T07:28:46+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/21</id><title>349. 两个数组的交集🤓🤓</title><updated>2023-05-12T11:32:08.605893+00:00</updated><content type="html"><![CDATA[<h2>哈希法—set集合实现</h2>
<h3>2.1 349. 两个数组的交集</h3>
<p><strong>一些提示：</strong></p>
<ul>
<li>
<p>如果哈希值比较少、特别分散、跨度非常大，使用数组就造成空间的极大浪费！</p>
</li>
<li>
<p>这道题目没有限制数值的大小，就无法使用数组来做哈希表了</p>
</li>
<li>
<p>直接使用set 不仅占用空间比数组大，而且速度要比数组慢，set把数值映射到key上都要做hash计算的</p>
</li>
</ul>
<blockquote>
<p>思路分析：简单的说就是，将一个数组转化成set集合，再将另外一个数组转化成set集合前判断是否在第一个集合出现过，出现过的再放到另外一个set结果集中。</p>
</blockquote>
<pre><code class="language-JAVA">class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        //判断临界条件
        if (nums1 == null || nums1.length == 0 || nums2 == null || nums2.length == 0) {
            return new int[0];
        }
        //先将数组nums1存入set集合中，它当然也会去重，set集合中不会出现重复的元素
        Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;();
        //存放结果
        Set&lt;Integer&gt; resSet = new HashSet&lt;&gt;();
        //遍历数组nums1
        for (int i : nums1) {
            set1.add(i);
        }
        //遍历数组nums2
        for (int i : nums2) {
            //判断nums1里面有没有
            if (set1.contains(i)) {
                resSet.add(i);
            }
        }

        //将集合转化为数组
        return resSet.stream().mapToInt(x -&gt; x).toArray();
/*这个代码使用了Java 8中的流(Stream) API，它提供了一种高效的方式来处理数据。
具体来说，这句话的各个部分的作用如下：
resSet.stream()：对 resSet 集合进行流操作，返回一个 Stream&lt;Integer&gt; 类型的流。
.mapToInt(x -&gt; x)：对流中的每个元素执行 map 操作，将元素映射成一个 int 类型的值。x -&gt; x 表示的是一个Lambda表达式，它的作用是将元素原封不动地映射成 int 类型。
.toArray()：将流中的所有 int 值存储在一个 int 数组中，然后将该数组作为结果返回。*/
</code></pre>
<ul>
<li>
</li>
</ul>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/21" rel="alternate"/><category term="算法"/><category term="哈希法"/><published>2023-05-11T07:24:00+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/20</id><title>时间复杂度❗</title><updated>2023-05-12T11:32:08.770049+00:00</updated><content type="html"><![CDATA[<p>如图所示：
<img src="https://s2.loli.net/2023/05/11/OJAsnZ8d7gpSVuz.png" alt="image-20230510150615098.png" />
(图来源不明，侵删，抱歉)</p>
<ul>
<li>
<p>常数阶：常数阶的操作数量与输入数据大小 n无关，即不随着 n的变化而变化</p>
</li>
<li>
<p>对数阶：与指数阶正好相反，后者反映“每轮增加到两倍的情况”，而前者反映“每轮缩减到一半的情况”。对数阶仅次于常数阶，时间增长得很慢，<strong>是理想的时间复杂度。</strong></p>
</li>
<li>
<p>线性阶：常出现于单层循环</p>
</li>
<li>
<p>线性对数阶：常出现于<strong>嵌套循环</strong>中，两层循环的时间复杂度分别为 O(log⁡n) 和 O(n) 。</p>
<p><strong>主流排序算法的时间复杂度都是 O(nlog⁡N) ，例如快速排序、归并排序、堆排序等</strong>。</p>
</li>
<li>
<p>平方阶：常出现于嵌套循环，外层循环和内层循环都为 O(n) </p>
</li>
<li>
<p>指数阶:增长得非常快，在实际应用中一般是不能被接受的。若一个问题使用「暴力枚举」求解的时间复杂度是 O(2^n) ，那么一般都需要使用**「动态规划」或「贪心算法」**等算法来求解</p>
</li>
</ul>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/20" rel="alternate"/><category term="算法"/><published>2023-05-11T07:08:16+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/19</id><title>LC242. 有效的字母异位词🤓🤓</title><updated>2023-05-12T11:32:08.936675+00:00</updated><content type="html"><![CDATA[<h2>哈希法—数组实现</h2>
<p><strong>思路分析</strong>：</p>
<p>使用一个数组记录字符串S出现的次数，若该字母出现了一次，该位置的元素值加一；再遍历另外一个字符串，若出现一次就在数组对应位置的值减一。</p>
<blockquote>
<p>因为字母是按顺序的，ASCII码上，每个字母也是相差1，随便取一个字母减去‘a’,就会得到该字母的下标了，然后在对应的record数组上，让该索引下的值+1</p>
</blockquote>
<p>时间复杂度：O(n)</p>
<p>空间复杂度：O(1)</p>
<pre><code class="language-java">class Solution {
    public boolean isAnagram(String s, String t) {
        //哈希法 用数组来实现
        //定义一个统计字母出现次数的字符串
        int[] record = new int[26];//开辟26个空间即可

        for (int i = 0; i &lt; s.length(); i++) {
            record[s.charAt(i) - &#x27;a&#x27;]++;//因为字母是按顺序的，ASCII码上，每个字母也是相差1，随便取一个字母减去‘a’,就会得到该字母的下标了，然后在对应的record数组上，让该索引下的值+1
        }
        for (int i = 0; i &lt; t.length(); i++) {
            record[t.charAt(i) - &#x27;a&#x27;]--;
        }
        //只要record数组里面，不是0的，说明该位置的元素在两个字符串中不相等
        for (int count: record) {
            if (count != 0) {
                return false;
            }
        }
        return true;
    }
}
</code></pre>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/19" rel="alternate"/><category term="算法"/><category term="哈希法"/><published>2023-05-11T06:58:36+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/18</id><title>LC215. 数组中的第K个最大元素</title><updated>2023-05-12T11:32:09.127235+00:00</updated><content type="html"><![CDATA[<h4>[<a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a>](https://leetcode.cn/problems/kth-largest-element-in-an-array/)</h4>
<pre><code class="language-java">class Solution {
    public int findKthLargest(int[] nums, int k) {
        // 快速排序 小的放到右边，大的放到左边即可
        quickSort(nums, 0, nums.length - 1);
        return nums[k - 1];

    }

    public int[] quickSort(int[] nums, int left, int right) {
        if (left &gt;= right) {
            return null;
        }
        int pivot = partion(nums, left, right);
        quickSort(nums, left, pivot - 1);
        quickSort(nums, pivot + 1,right);
        return nums;
    }

    public int partion(int[] nums, int left, int right) {
        int pivot = nums[left];

        while (left &lt; right) {
            while (left &lt; right &amp;&amp; nums[right] &lt;= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left &lt; right &amp;&amp; nums[left] &gt;= pivot) {
                left++;
            }
            nums[right] = nums[left];
        }

        nums[left] = pivot;
        return left;
    }
}
</code></pre>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/18" rel="alternate"/><category term="算法"/><category term="排序"/><published>2023-05-11T06:41:05+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/17</id><title>LC912. 排序数组 </title><updated>2023-05-12T11:32:09.299166+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>理论基础：快速排序是一种常见的排序算法，使用分治的思想来排序一个数组或列表。它的基本思想是选择一个<strong>基准数</strong>，<strong>将数组分成两个部分</strong>，一部分是小于基准数的，另一部分是大于等于基准数的，然后再对这两部分递归地进行排序。</p>
</blockquote>
<p>好的情况：<strong>时间复杂度：nlogn</strong></p>
<p>具体步骤如下：</p>
<ol>
<li>选择一个基准数（pivot），可以选择第一个数、最后一个数、中间的数或者随机数。</li>
<li>将数组中<strong>小于等于</strong>基准数的元素放在基准数的左边，大于基准数的元素放在基准数的右边，这一步称为**“划分**”（partition）操作。</li>
<li>对基准数左边的子数组进行<strong>递归</strong>排序，对基准数右边的子数组进行<strong>递归排序</strong>，直到每个子数组的长度为 0 或 1，排序完成。</li>
</ol>
<pre><code class="language-JAVA">class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }
    // 快速排序函数
    public static int[] quickSort(int[] nums, int left, int right) {
        if (left &gt;= right) {
            return null;
        }
        int partition = partition(nums, left, right);
        quickSort(nums, left, partition - 1);//在划分位置的左边子区域再划分，直到不可划分left &gt;= right不能进循环条件
        quickSort(nums, partition + 1, right); //在划分位置的右边子区域再划分，直到不可划分left &gt;= right不能进循环条件
        return nums;
    }

    public static int partition(int[] nums, int left, int right) {
        int pivot = nums[left];
        while (left &lt; right) {
            while (left &lt; right &amp;&amp; nums[right] &gt;= pivot) {
                right--;
            }
            nums[left] = nums[right];
            while (left &lt; right &amp;&amp; nums[left] &lt;= pivot) {
                left++;
            }
            nums[right] = nums[left];
        }
        nums[left] = pivot; //当前left，right 指向同一个位置了 nums[right] = pivot也行
        return left;// 返回划分的位置
    }
}
</code></pre>
<p>缺点：如果输入的数组是基本有序的，快速排序的效率会受到影响，因为快速排序的时间复杂度在最坏情况下是 O(n^2)，即每次划分都只划分出一个子区间。如果输入的数组基本有序，<strong>每次划分可能都会划分出极度不平衡的子区间</strong>，使得快排退化成冒泡排序。</p>
<blockquote>
<p>双轴快排</p>
</blockquote>
<p><strong>分析</strong>：双轴快排是一种改进的快速排序算法，其基本思想是将待排序数组划分成三个区域：小于基准元素的区域、等于基准元素的区域和大于基准元素的区域。与传统快排相比，双轴快排使用两个轴值，分别从两端扫描数组，将数组划分成三个区域。具体流程如下：</p>
<ol>
<li>
<p>选取两个轴值p和q，p&lt;q，将数组分成左、中、右三个部分，左部分中所有元素均小于p，右部分中所有元素均大于q，中部分中所有元素均介于p和q之间。</p>
</li>
<li>
<p>对中部分进行递归排序。</p>
</li>
<li>
<p>对左、右部分进行递归排序。</p>
</li>
</ol>
<p>由于双轴快排采用两个轴值进行划分，因此每次划分可以减少更多的无用比较，从而提高了排序效率。同时，由于其采用了三路划分的思想，可以处理包含大量重复元素的数组。</p>
<p>双轴快排的时间复杂度为O(nlogn)，与传统快排相同，但是实际运行效率更高，尤其是<strong>在处理包含大量重复元素的数组时。</strong></p>
<pre><code class="language-java">class Solution {
    public int[] sortArray(int[] nums) {
        dualPivotQuickSort(nums, 0, nums.length - 1);
        return nums;
    }
    
    private void dualPivotQuickSort(int[] nums, int left, int right) {
        if (left &gt;= right) {
            return;
        }
        if (nums[left] &gt; nums[right]) {
            swap(nums, left, right);
        }
        int pivot1 = nums[left], pivot2 = nums[right];
        int i = left + 1, lt = left + 1, gt = right - 1;
        while (i &lt;= gt) {
            if (nums[i] &lt; pivot1) {
                swap(nums, i++, lt++);
            } else if (nums[i] &gt; pivot2) {
                swap(nums, i, gt--);
            } else {
                i++;
            }
        }
        swap(nums, left, --lt);
        swap(nums, right, ++gt);
        dualPivotQuickSort(nums, left, lt - 1);
        dualPivotQuickSort(nums, lt + 1, gt - 1);
        dualPivotQuickSort(nums, gt + 1, right);
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

</code></pre>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/17" rel="alternate"/><category term="算法"/><category term="排序"/><published>2023-05-11T06:38:11+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/16</id><title>LC 20.有效的括号⭐⭐⭐⭐</title><updated>2023-05-12T11:32:09.468227+00:00</updated><content type="html"><![CDATA[<p>20.有效的括号🤓🤓</p>
<ul>
<li><strong>括号匹配是使用栈解决的经典问题</strong></li>
</ul>
<p><strong>思路分析</strong>：</p>
<p>分析三种情况：</p>
<ul>
<li>第一种：左括号多了（栈中遗留了一个右括号），缺右括号</li>
<li>第二种：括号的类型没有匹配上</li>
<li>第三种：没有左括号了，右括号多了；字符串还没遍历，栈就为空了</li>
</ul>
<p><strong>代码步骤：</strong></p>
<ul>
<li>遇到左括号、左花括号、左中括号就往栈中放入相应的右括号、右花括号、右中括号</li>
</ul>
<p>剪枝的条件：</p>
<blockquote>
<p>字符串—长度是奇数的话是一定不匹配的</p>
</blockquote>
<p><strong>题解：</strong></p>
<pre><code class="language-java">class Solution {
    public boolean isValid(String s) {
        //创建一个栈，存放字符
        Deque&lt;Character&gt; deque = new LinkedList&lt;&gt;();
        char ch;
        for (int i = 0; i &lt; s.length(); i++) {
            ch = s.charAt(i);
            //碰到左括号，就把相应的右括号放入栈中
            if (ch == &#x27;(&#x27;) {
                deque.push(&#x27;)&#x27;);//压入
            } else if (ch == &#x27;[&#x27;) {
                deque.push(&#x27;]&#x27;);
            } else if (ch == &#x27;{&#x27;) {
                deque.push(&#x27;}&#x27;);
            }//处理第三种情况和第二种情况，即第三种：栈为空了，栈没有要去匹配的右括号了
            //第二种：栈里面的右括号和字符串遍历的左括号不匹配
             else if (deque.isEmpty() || deque.peek() != ch) {
                 return false;
             } else {
                 deque.pop();//弹出
             }
        }
        //遍历完字符串了，最后解决第一种情况：就是栈中多出来了右括号，但是字符串已经遍历完了
        //判断最后的栈内为不为空 不为空放的肯定是右括号
        return deque.isEmpty();//不为空返回false
    }
}
</code></pre>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/16" rel="alternate"/><category term="算法"/><category term="栈"/><published>2023-05-10T06:39:17+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/15</id><title>LC 704.二分查找⭐⭐⭐⭐</title><updated>2023-05-12T11:32:09.635515+00:00</updated><content type="html"><![CDATA[<p>704.二分查找🤓🤓
<strong>思路分析：</strong></p>
<blockquote>
<p>二分查找法是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半</p>
</blockquote>
<pre><code class="language-java">public int binarySearch(int[] nums, int target) {
        // 在区间[left,right]中查找元素，左闭右闭
        int left = 0;
        int right = nums.length - 1;

        // 由于是在区间[left,right]中查找
        // 因此当left=right时，区间内还有一个元素需要查找
            while (left &lt;= right) {
            // 计算中间点
            int mid = left + (right-left)/2;

            // 如果target == nums[mid]则表示已经找到，返回mid
            if (target == nums[mid]) {
                return mid;
                // 如果target &lt; nums[mid]，表示目标值可能在左半边
            } else if (target &lt; nums[mid]){
                // 由于是在左闭右闭的区间[left,right]中查找
                // 而target &lt; nums[mid]，因此mid不再需要考虑
                // 所以right = mid - 1,即在[left,mid-1]中继续查找
                right = mid - 1;

                // 如果target &gt; nums[mid]，表示目标值可能在右半边
            } else if (target &gt; nums[mid]){
                // 由于是在左闭右闭的区间[left,right]中查找
                // 而target &gt; nums[mid]，因此mid不再需要考虑
                // 所以left = mid + 1，即在[mid+1,right]中继续查找
                left = mid + 1;
            }
        }

        // 未找到返回-1
        return -1;
    }
</code></pre>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/15" rel="alternate"/><category term="算法"/><category term="二分查找"/><published>2023-05-10T06:31:49+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/14</id><title>LC 27.移除元素 &amp; 26.删除排序数组中的重复项⭐⭐⭐⭐</title><updated>2023-05-12T11:32:09.811297+00:00</updated><content type="html"><![CDATA[<h3>快慢指针</h3>
<p><strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。</strong></p>
<ul>
<li>
<p>暴力解法时间复杂度：O(n^2)</p>
</li>
<li>
<p>双指针时间复杂度：O(n)</p>
</li>
</ul>
<p>27.移除元素🤓🤓
<a href="https://leetcode.cn/problems/remove-element/">https://leetcode.cn/problems/remove-element/</a></p>
<p>快慢指针：<strong>通过一个快指针和慢指针在一个for循环下完成两个for循环的工作</strong></p>
<pre><code class="language-java">class Solution {
    public int removeElement(int[] nums, int val) {
        int slowIndex = 0;//定义慢指针
        for (int fastIndex = 0; fastIndex &lt; nums.length; fastIndex++) {
            //快指针去查找数组的值是否等于val 
            if (val != nums[fastIndex]) {
                //nums[slowIndex++] = nums[fastIndex];
                nums[slowIndex] = nums[fastIndex];
                slowIndex++;
            }
        }
        return slowIndex;
    }
}
</code></pre>
<p>26.删除排序数组中的重复项🤓🤓</p>
<p><strong>思路分析</strong>：</p>
<blockquote>
<p>利用数组有序的特点，可以通过双指针的方法删除重复元素。定义两个指针 fast 和 slow 分别为快指针和慢指针，快指针表示遍历数组到达的下标位置，慢指针表示下一个不同元素要填入的下标位置，初始时两个指针都指向下标 1。当数组的长度大于0的时候，至少都包含了一个不重复的元素，因此，nums[0]保持原状即可，从下标1开始。</p>
</blockquote>
<p>链接：<a href="https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/">https://leetcode.cn/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-tudo/</a></p>
<pre><code class="language-java">class Solution {
    public int removeDuplicates(int[] nums) {   
        //判断数组是否为0
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int fast = 1, slow = 1;//从1开始 因为数组至少有一个元素是不重复的
        while (fast &lt; n) {//如果整个数组包括0的话，要&lt;=n
            if (nums[fast] != nums[fast - 1]) {
                nums[slow] = nums[fast];//不相等则记录在慢指针中
               // slow = slow + 1 ;//先加了再赋值
                ++slow;
            }
            ++fast;
        }
        return slow;
    }
}
</code></pre>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/14" rel="alternate"/><category term="算法"/><category term="双指针"/><published>2023-05-10T06:29:04+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/13</id><title>📌刷题策略</title><updated>2023-05-12T11:32:10.010096+00:00</updated><content type="html"><![CDATA[<h3>以下是个人总结的刷题方法💡</h3>
<ul>
<li>
<p>初刷（<strong>一题控制在半小时</strong>）</p>
<blockquote>
<p>5分钟内没有头绪，直接看题解，尽力去理解，用规范的代码风格，&quot;抄写&quot;，不懂也没关系，以后再看。</p>
</blockquote>
</li>
<li>
<p>精刷（<strong>一题控制在1小时</strong>）</p>
<blockquote>
<p>针对初刷未理解的题，尽量全面理解答案的要义，至少能够&quot;默写&quot;出来，调试通过。将解题的思路，以及标准的答案记录到笔记中,笔记做好分类。如果还是未能理解，做好标记。</p>
</blockquote>
</li>
<li>
<p>过题（<strong>一题控制在5——10分钟</strong>）</p>
<blockquote>
<p>按照分类的笔记，大量复习题目。大脑过一遍解题思路，跟正确思路对比是否正确。不需要写题</p>
</blockquote>
</li>
<li>
<p>复刷（<strong>一题控制在20分钟</strong>）</p>
<blockquote>
<p>自言自语分析理解题意，讲清楚自己的思路，写题，检查，一遍跑通！</p>
</blockquote>
</li>
<li>
<p>模拟（<strong>一题控制在30分钟</strong>）</p>
<blockquote>
<p>做一道新题，看看是否能达到复刷的效果，计入笔记。</p>
</blockquote>
</li>
</ul>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/13" rel="alternate"/><category term="TOP"/><published>2023-05-10T06:22:07+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/12</id><title>于香港中文大学</title><updated>2023-05-12T11:32:10.205966+00:00</updated><content type="html"><![CDATA[<p>这次省赛原本是2022年应该举办的，但是由于疫情延迟到了今天，本次的举办地点香港中文大学深圳校区，先附上几张图片吧。
<img src="https://user-images.githubusercontent.com/72082506/233777613-10306e27-b9eb-45f0-962d-9cb7e95a5523.jpeg" alt="mmexport42474e6a459898e414415f83633a8d1a_1682136901577" />
<img src="https://user-images.githubusercontent.com/72082506/233777623-267a2964-b349-4601-813d-95208364df1f.jpg" alt="20230421_235020" /></p>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/12" rel="alternate"/><category term="Orienteering"/><published>2023-04-22T10:07:33+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/11</id><title>5月份计划🗓️</title><updated>2023-05-12T11:32:10.378778+00:00</updated><content type="html"><![CDATA[<ul>
<li><input checked="" disabled="" type="checkbox"> 算法笔记迁移 &amp; 复习旧题</li>
<li><input checked="" disabled="" type="checkbox"> 分类总结八股文</li>
<li><input checked="" disabled="" type="checkbox"> 简历项目面试准备</li>
<li><input checked="" disabled="" type="checkbox"> 完成工作室项目开发进度</li>
<li><input disabled="" type="checkbox"> 准备软考</li>
<li><input disabled="" type="checkbox"> 完善wyy项目</li>
</ul>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/11" rel="alternate"/><category term="TODO"/><published>2023-04-18T01:47:17+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/10</id><title>蓝桥杯又要摆烂了~</title><updated>2023-05-12T11:32:10.547534+00:00</updated><content type="html"><![CDATA[<p>这段时间也没怎么刷蓝桥的题了，感觉8号的蓝桥杯要g，也算是预料之内吧。当然，当初报名的初心就是能通过报名算法类的竞赛，提高自己的算法能力，然后大概100天的时间，也刷了LC大概160道（摆烂式刷题），系统学了数据结构等知识，也总结了算法笔记，让自己对曾经不敢接触的东西，有了新的认知。总之，收获还是有的，这300块的报名费，值得，目的算是达到了。希望后面的时间，也要继续做题，冲。</p>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/10" rel="alternate"/><category term="碎碎念"/><published>2023-04-06T01:53:01+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/9</id><title>数据库又被黑了 真佛了...</title><updated>2023-05-12T11:32:10.734903+00:00</updated><content type="html"><![CDATA[<h2>README_TO_RECOVER_YOUR_DATA</h2>
<blockquote>
<p>由于自己练手项目的数据库用的mongodb，想着练手，不重要，当时没做安全考虑，将配置文件上传到了仓库。后来想着还是添加到忽略的文件中，但是不起作用，改得了一次提交，改不了所有的提交记录，由于之前的提交记录仍然存在账号密码，想着应该没人会搞吧，即使搞了也不重要，就没去折腾了。</p>
</blockquote>
<p>好家伙，话音刚落，第二天，拿不到后台数据，发现被黑了，这是第一次
<img src="https://user-images.githubusercontent.com/72082506/228608648-49ab7a7d-4ffe-4e59-8097-0d141bea5bfb.png" alt="image-20230316112619224" /></p>
<p>要我比特币,后来直接回封邮件给他 f<strong>k y  ** m</strong>
当时的处置方法是，重新删掉原来的数据库，再创建mogodb容器，设置账号密码（设的比较简单）</p>
<p>3.29，前端又拿不到数据了，发现数据库又被黑了 6 ，这一次是另外的人</p>
<p><img src="https://user-images.githubusercontent.com/72082506/228609215-a8a78a73-157c-4e2a-98b6-d2aac3a25c35.png" alt="3dcb3a76d79e1db8b338fb74b0ed4e2" /></p>
<p>还是同样的操作，重建了数据库，这次快多了。设置了比较强的密码！！</p>
<p>期待下一次！🥲
💤</p>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/9" rel="alternate"/><category term="碎碎念"/><published>2023-03-29T16:46:07+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/8</id><title>报了软考 预言家说：铁定能过！</title><updated>2023-05-12T11:32:10.907585+00:00</updated><content type="html"><![CDATA[<h2>距离2023.5.27日还有大概两个月⏰</h2>
<p>接下来的日子里，忙项目、背面经、找实习、备考等等，似乎忙不过来了
计划一下，好好渡过，忙有所得，忙有所思
加油吧！ </p>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/8" rel="alternate"/><category term="碎碎念"/><published>2023-03-25T10:52:03+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/7</id><title>友情链接格式✔️</title><updated>2023-05-12T11:32:11.087525+00:00</updated><content type="html"><![CDATA[<p>显示到友情链接的方法：评论，然后将下面对应部分替换成你的，我点了爱心就可以自动添加啦。
名字：HealUP
链接：<a href="https://github.com/HealUP/MyBlog">https://github.com/HealUP/MyBlog</a>
描述：blog</p>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/7" rel="alternate"/><category term="TOP"/><category term="Friends"/><published>2023-03-25T05:15:45+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/6</id><title>4月份就要结束了，一些要做的事</title><updated>2023-05-12T11:32:11.286540+00:00</updated><content type="html"><![CDATA[<h2>4月份-4月中旬</h2>
<ul>
<li><input checked="" disabled="" type="checkbox"> 总结好项目</li>
<li><input checked="" disabled="" type="checkbox"> 投简历</li>
<li><input checked="" disabled="" type="checkbox"> 接收工作室项目</li>
</ul>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/6" rel="alternate"/><category term="TODO"/><published>2023-03-24T13:14:38+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/4</id><title>README看起来更顺眼了！😁</title><updated>2023-05-12T11:32:11.456536+00:00</updated><content type="html"><![CDATA[<p>参考了大佬们的博客，抽了点时间美化了一下readme，主要做了以下几件事</p>
<ul>
<li>wakatime 数据显示</li>
</ul>
<ol>
<li>常用编辑器上装好插件wakatime </li>
<li>获取token </li>
<li>github actions 定期更新</li>
<li>自定义个人的actions</li>
</ol>
<ul>
<li>仓库的概览</li>
<li>Top language </li>
<li>Extra pin 放了简历上的两个项目
花了点时间折腾，之前想着放年贪吃蛇吃贡献砖块的，还不小心给另外的actions给覆盖了，又让我重搞readme,崩溃🥲 又多折腾了会</li>
</ul>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/4" rel="alternate"/><category term="Trying"/><published>2023-03-24T12:30:58+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/3</id><title>给个人PC加了一根16G的内存条，有点起飞的感觉！</title><updated>2023-05-12T11:32:11.629147+00:00</updated><content type="html"><![CDATA[<blockquote>
<p>电脑买的是拯救者的y7000,20款的，当时花了6100左右，想着以后可以自己扩展内存条，并且对硬盘空间要求不是很大，就买了8g的内存，512的硬盘款的，便宜点。具体配置:</p>
</blockquote>
<p><img src="https://user-images.githubusercontent.com/72082506/227256029-50aa38a4-6a80-4ccd-b85c-37e659b30ba8.png" alt="image" /></p>
<ul>
<li>原装内存条是8G，一年前买了一根8G的加了进去，当时是220r,老贵了。后来发现写项目跑微服务，内存一下子飙到99％🥲很不流畅，为了提高体验感，让电脑更加流畅点，索性换了16G的进去，现在好多了，同时跑多个服务+开多个软件+网页浏览，大概60％左右，爽，速度明显提高，体验感倍儿好。</li>
</ul>
<p><img src="https://user-images.githubusercontent.com/72082506/227259258-862929bf-7e14-43a0-9a66-07aff7a508ba.jpg" alt="0988cbc17653e4404b389f76f56d4bf" /></p>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/3" rel="alternate"/><category term="Trying"/><published>2023-03-23T15:53:29+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/2</id><title>支持RSS订阅</title><updated>2023-05-12T11:32:11.796815+00:00</updated><content type="html"><![CDATA[<p>大家可以将RSS链接添加到阅读器里，方便及时获取到博客的内容，感谢关注~❤️</p>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/2" rel="alternate"/><category term="Trying"/><published>2023-03-23T08:16:09+00:00</published></entry><entry><id>https://github.com/HealUP/MyBlog/issues/1</id><title>GitBlog 诞生</title><updated>2023-05-12T11:32:11.972454+00:00</updated><content type="html"><![CDATA[<ul>
<li>
<p>测试actions</p>
</li>
<li>
<p>问题
<img src="https://user-images.githubusercontent.com/72082506/227095200-018069ab-c149-484f-9cd7-9706c6390130.png" alt="image" /></p>
</li>
<li>
<p>问题解决
<img src="https://user-images.githubusercontent.com/72082506/227139341-7963b2c1-8475-4648-9545-2e8e42de1087.png" alt="image" /></p>
</li>
<li>
<p><input disabled="" type="checkbox"> over! 把自己Typora 的博客都迁移到这!</p>
</li>
</ul>
]]></content><link href="https://github.com/HealUP/MyBlog/issues/1" rel="alternate"/><category term="Trying"/><published>2023-03-23T03:25:51+00:00</published></entry></feed>